"""
script_generator.py

Hybrid Script Generator (Gemini-based)
- Option A: Cinematic smooth subtle motion (selected)
- Hybrid template approach: first 3 scenes are fixed, scenes 4..N generated by Gemini 2.0 Flash
- Produces structured JSON output that's VEO + Nano Banana safe

Notes:
- This implementation uses the Google `genai` client if available (recommended).
- If `genai` is not available, code falls back to a local simple generator so your pipeline keeps working.
- Environment variable required: GEMINI_API_KEY (for genai)

"""

import os
import json
import asyncio
import time
from typing import Dict, Any, List, Optional
from dotenv import load_dotenv

load_dotenv()


# Try to import the Google genai client. If it's not installed, we'll gracefully fallback.
try:
    from google import genai
    GENAI_AVAILABLE = True
except Exception:
    genai = None  # type: ignore
    GENAI_AVAILABLE = False


class ScriptGenerator:
    """Generate VEO-safe campaign scripts using Gemini (preferred) or local fallback.

    - Hybrid approach: scenes 1..3 are stable templates (Arrival, Service, Portrait)
    - Scenes 4..N are generated by Gemini 2.0 Flash (short, tightly constrained prompts)
    - Motion style: Cinematic smooth subtle motion (Option A)
    """

    def __init__(self):
        self.model = "gemini-2.0-flash"  # recommended low-cost Gemini model for text
        self.api_key = os.getenv("GEMINI_API_KEY")
        if GENAI_AVAILABLE and not self.api_key:
            raise Exception("GEMINI_API_KEY environment variable is required for Gemini generation")

        # If genai is available, create a client instance lazily
        self.client = None
        if GENAI_AVAILABLE:
            self.client = genai.Client(api_key=self.api_key)

        # Motion style A: cinematic smooth subtle motion
        self.motion_style = "Smooth subtle cinematic push-in / slight parallax, stable framing, gentle natural motion."

        print("ü§ñ Hybrid ScriptGenerator initialized (Gemini preferred)")

    # -------------------------
    # Public API
    # -------------------------
    async def generate_campaign_script(
        self,
        product_description: str,
        has_character: bool,
        num_scenes: int = 3,
        business_type: str = "beauty",
        platform: str = "Instagram Reels",
        max_generated_scenes: int = 10
    ) -> Dict[str, Any]:
        """Generate a campaign script.

        Returns a dict with keys: campaign_theme, color_palette, scenes (list)
        """

        # clamp scenes
        num_scenes = max(3, min(num_scenes, max_generated_scenes))

        # Build base result
        campaign_theme = f"{business_type.title()} Campaign"
        color_palette = ["#F5E6E8", "#D8C4B6", "#A89F8E"]  # tasteful defaults; UI may override

        # Templates for first 3 scenes (very stable)
        template_scenes = self._get_template_scenes(business_type)

        scenes: List[Dict[str, Any]] = []

        # Add templates (1..3)
        for t in template_scenes[:3]:
            scene = {
                "scene_number": t["scene_number"],
                "title": t["title"],
                "description": t["description"],
                "setting": t.get("setting", "clean modern interior"),
                "character_action": t.get("action", "natural, candid"),
                "mood": t.get("mood", "warm, welcoming"),
                "camera_movement": self.motion_style,
                "lighting": "soft natural fill, even exposure",
                "background": "simple uncluttered background with subtle seasonal touches",
                "caption_text": t.get("caption", t["title"]),
                "hashtags": [f"#{business_type.replace(' ', '')}", "#ad"],
                "duration": 8
            }
            scenes.append(scene)

        # Generate additional scenes (4..num_scenes) via Gemini if requested
        if num_scenes > 3:
            to_gen = num_scenes - 3
            gen_scenes = await self._generate_additional_scenes_via_gemini(
                product_description=product_description,
                has_character=has_character,
                business_type=business_type,
                num_scenes=to_gen
            )

            # gen_scenes is a list of scene dicts with the same structure
            scenes.extend(gen_scenes)

        # Final result
        result = {
            "campaign_theme": campaign_theme,
            "color_palette": color_palette,
            "scenes": scenes
        }

        return result

    # -------------------------
    # Templates
    # -------------------------
    def _get_template_scenes(self, business_type: str) -> List[Dict[str, Any]]:
        """Return the three canonical template scenes tailored by business_type"""
        bt = business_type.lower()

        if "nail" in bt:
            return [
                {
                    "scene_number": 1,
                    "title": "Arrival - Entrance",
                    "description": "Wide shot of person entering the salon, full body visible, walking naturally, soft smile. Face fully visible and sharp.",
                    "action": "entering, mid-stride",
                    "mood": "inviting"
                },
                {
                    "scene_number": 2,
                    "title": "Service - Station",
                    "description": "Medium close-up at manicure station. Hands visible but not blocking face. Face unobstructed and well lit.",
                    "action": "sitting at station",
                    "mood": "relaxed"
                },
                {
                    "scene_number": 3,
                    "title": "Final Portrait - Hero",
                    "description": "Portrait shoulders-up, genuine smile, one hand near face but not covering it. Sharp face, natural skin texture.",
                    "action": "posing with nails visible",
                    "mood": "confident"
                }
            ]

        if "hair" in bt:
            return [
                {
                    "scene_number": 1,
                    "title": "Arrival - Entrance",
                    "description": "Wide shot of person entering the salon, full body visible, carrying bag, natural smile. Face fully visible.",
                    "action": "entering",
                    "mood": "anticipatory"
                },
                {
                    "scene_number": 2,
                    "title": "Consultation - Mirror",
                    "description": "Medium shot through the mirror (ensure face in original camera frame is unobstructed); subject seated, stylist off-frame.",
                    "action": "sitting and consulting",
                    "mood": "engaged"
                },
                {
                    "scene_number": 3,
                    "title": "Reveal - New Style",
                    "description": "Medium close-up showing finished hair; face visible and sharp, minimal hands near face.",
                    "action": "turning head, smiling",
                    "mood": "delighted"
                }
            ]

        if "spa" in bt:
            return [
                {
                    "scene_number": 1,
                    "title": "Arrival - Welcome",
                    "description": "Wide shot of calm spa entrance; person walking in, relaxed posture, face visible.",
                    "action": "entering",
                    "mood": "calm"
                },
                {
                    "scene_number": 2,
                    "title": "Preparation - Treatment",
                    "description": "Medium shot awaiting treatment, shoulders-up, face unobstructed, peaceful expression.",
                    "action": "waiting peacefully",
                    "mood": "serene"
                },
                {
                    "scene_number": 3,
                    "title": "Bliss - Post Treatment",
                    "description": "Portrait after treatment, happy content expression, face sharp and natural.",
                    "action": "smiling relaxed",
                    "mood": "content"
                }
            ]

        # Default generic templates
        return [
            {
                "scene_number": 1,
                "title": "Arrival - Entrance",
                "description": "Wide shot of person entering location, full body visible, natural smile.",
                "action": "entering",
                "mood": "warm"
            },
            {
                "scene_number": 2,
                "title": "Service - Station",
                "description": "Medium shot at the service station; face visible and well-lit.",
                "action": "interacting",
                "mood": "friendly"
            },
            {
                "scene_number": 3,
                "title": "Final Portrait - Hero",
                "description": "Portrait shoulders-up, natural smile, face sharp.",
                "action": "posing",
                "mood": "confident"
            }
        ]

    # -------------------------
    # Gemini generation for extra scenes
    # -------------------------
    async def _generate_additional_scenes_via_gemini(
        self,
        product_description: str,
        has_character: bool,
        business_type: str,
        num_scenes: int
    ) -> List[Dict[str, Any]]:
        """Generate num_scenes additional scene dicts using Gemini text model.

        If Gemini client is not available or the call fails, return simple fallback scenes.
        """

        # Safety clamp
        num_scenes = max(0, min(num_scenes, 7))

        # Build a short instruction for Gemini
        system_instructions = (
            "You are a concise advertising director. Generate short VEO-safe scene definitions (50-80 words)"
            " for a beauty/hair/spa campaign. Keep each scene focused, ensure face visibility, avoid bokeh/blur, no hands covering face," 
            "no mirror reflections, no stylist in frame, no f-stop, no cinematic bokeh, no mention of lens metadata."
        )

        user_instructions = (
            f"BusinessType: {business_type}. Product: {product_description}. MotionStyle: Cinematic smooth subtle movement. "
            f"Return exactly {num_scenes} JSON objects as an array. Each object must include: title, description, action, setting, mood, camera_movement (short)."
        )

        # If genai client is available, call Gemini; otherwise fallback
        if GENAI_AVAILABLE and self.client:
            try:
                # Many genai python SDKs expose a responses/text generation method; attempt a generic call.
                # Implementation may need small adjustments to match the exact genai sdk in your environment.
                prompt = system_instructions + "\n\n" + user_instructions

                # deploy a simple, robust call with a short timeout; non-blocking wrapper
                gen_response = await asyncio.to_thread(
                    lambda: self.client.generate_text(
                        model=self.model,
                        prompt=prompt,
                        max_output_tokens=800
                    )
                )

                raw_text = getattr(gen_response, "text", None) or str(gen_response)

                # Heuristic: try to parse JSON from response; support responses that already output JSON
                parsed = None
                try:
                    parsed = json.loads(raw_text)
                except Exception:
                    # attempt to find JSON substring
                    start = raw_text.find("[")
                    end = raw_text.rfind("]")
                    if start != -1 and end != -1:
                        json_sub = raw_text[start:end+1]
                        try:
                            parsed = json.loads(json_sub)
                        except Exception:
                            parsed = None

                if isinstance(parsed, list) and len(parsed) > 0:
                    # normalize into expected scene dicts
                    out_scenes = []
                    base_number = 4
                    for i, item in enumerate(parsed[:num_scenes]):
                        out = {
                            "scene_number": base_number + i,
                            "title": item.get("title", f"Scene {base_number+i}"),
                            "description": item.get("description", ""),
                            "setting": item.get("setting", "clean modern interior"),
                            "character_action": item.get("action", "natural"),
                            "mood": item.get("mood", "neutral"),
                            "camera_movement": item.get("camera_movement", self.motion_style),
                            "lighting": item.get("lighting", "soft natural fill"),
                            "background": item.get("background", "clean minimal"),
                            "caption_text": item.get("caption_text", item.get("title", "")),
                            "hashtags": item.get("hashtags", [f"#{business_type.replace(' ', '')}" ]),
                            "duration": item.get("duration", 8)
                        }
                        out_scenes.append(out)

                    return out_scenes

                # If parsing failed, fall through to fallback
                print("‚ö†Ô∏è Gemini response could not be parsed as JSON; using fallback scenes")

            except Exception as e:
                print("‚ö†Ô∏è Gemini scene generation failed:", e)

        # Fallback simple auto-generated scenes (guaranteed safe)
        fallback = []
        base = 4
        for i in range(num_scenes):
            n = base + i
            fallback.append({
                "scene_number": n,
                "title": f"Extra Scene {n}",
                "description": f"Medium shot showing subject in a clean {business_type} environment; face clearly visible and well lit.",
                "setting": "clean modern interior",
                "character_action": "casual natural movement",
                "mood": "pleasant",
                "camera_movement": self.motion_style,
                "lighting": "soft natural fill",
                "background": "minimal decor",
                "caption_text": f"Scene {n}",
                "hashtags": [f"#{business_type.replace(' ', '')}"],
                "duration": 8
            })

        return fallback


# Singleton
script_generator = ScriptGenerator()
